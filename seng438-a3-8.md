**SENG 438 - Software Testing, Reliability, and Quality**

**Lab. Report #3 – Code Coverage, Adequacy Criteria and Test Case Correlation**

| Group: 8        |
| --------------- |
| Jiawei He       |
| Nicholas Garcia |
| Sarah Qin       |
| Findlay Brown   |

(Note that some labs require individual reports while others require one report
for each group. Please see each lab document for details.)

# 1 Introduction

This assignment focuses on JUnit testing and testing tools using white-box coverage criteria technique for test suites. The objective of this assignment is to equip students with the adequacy of a white-box test suite based on code coverage.

In order to measure the adequacy of a test suite, this assignment covers control-flow coverage criteria such as statement coverage, decision coverage, condition coverage and path coverage, and data-flow coverage criteria such as DU pairs coverage.

# 2 Manual data-flow coverage calculations for X and Y methods

1. Data Flow Graph
   - DataUtilities.calculateColumnTotal
   - Range.Intersects
1. the def-use sets per statement
   - DataUtilities.calculateColumnTotal
   - Range.Intersects
1. list all DU-pairs per variable
   - DataUtilities.calculateColumnTotal
     - data: (1, 1), (1, 3), (1, 5), (1, 12)
     - column: (1, 5), (1, 12)
     - total: (2, 7), (2, 10), (15, 15)
     - rowCount: (3, 4), (3, 9)
     - r: (4, 4), (4, 5), (4, 8)
     - n: (5, 7), (5, 12), (5, 13), (5, 15)
     - r2: (9, 12), (9, 14)
   - Range.Intersects
     - b0: (1, 1), (1, 3)
     - b1: (1, 2), (1, 3)
1. for each test case show which pairs are covered
   - DataUtilities.calculateColumnTotal
   - Range.Intersects
     - (1, 1), (1, 2), (1, 3)
1. calculate the DU-Pair coverage.
   - DataUtilities.calculateColumnTotal
   - Range.Intersects

# 3 A detailed description of the testing strategy for the new unit test

Text…

# 4 A high level description of five selected test cases you have designed using coverage information, and how they have increased code coverage

Text…

# 5 A detailed report of the coverage achieved of each class and method (a screen shot from the code cover results in green and red color would suffice)

Branch coverage of DataUtilities before changes were made

![](pictures/DataUtilities_old_branch_coverage.PNG)

Line coverage of DataUtilities before changes were made

![](pictures/DataUtilities_old_line_coverage.PNG)

Branch coverage of DataUtilities after changes were made

![](pictures/DataUtilities_new_branch_coverage.PNG)

Line coverage of DataUtilities after changes were made

![](pictures/DataUtilities_new_line_coverage.PNG)

Branch coverage of Range before changes were made

![](pictures/Range_old_branch_coverage.PNG)

Line coverage of DataUtilities before changes were made

![](pictures/Range_old_line_coverage.PNG)

Branch coverage of DataUtilities after changes were made

![]() **add screenshot here**

Line coverage of DataUtilities after changes were made

![]() **add screenshot here**


# 6 Pros and Cons of coverage tools used and Metrics you report

Text…

# 7 A comparison on the advantages and disadvantages of requirements-based test generation and coverage-based test generation.

***Advantages and Disadvantages of Requirements-Based Testing Generation***

Testing based on requirements helps pinpoint bugs by concentrating on known functionalities, avoiding unnecessary metrics. While this approach streamlines bug discovery, challenges may arise in deciding how many test cases are needed, possibly resulting in redundant and time-consuming tests that offer little value.

***Advantages and Disadvantages of Coverage-Based Testing Generation***

Generating tests based on coverage ensures a clear requirement for the number of tests in a project, offering a measurable metric to gauge testing completeness. Developers discover untested code areas and functionalities when striving to enhance coverage. However, a downside is the risk of testers prioritizing coverage metrics over addressing real issues, leading to undetected bugs in a codebase with high coverage metrics.

Requirements-based testing pinpoints bugs by focusing on known functionalities, avoiding unnecessary metrics, but may lead to challenges in determining test quantity. Coverage-based testing ensures clear test quantity requirements, offering a measurable metric for completeness, yet poses a risk of testers prioritizing metrics over addressing real issues, potentially leading to undetected bugs in a highly covered codebase. Balancing these approaches is crucial for effective testing.


# 8 A discussion on how the team work/effort was divided and managed

The team was split into pairs to develop the test suites using the white-box testing method. Test cases for all methods of the DataUtilities class was assigned to Findlay- and Javy, and all methods of the Range class was assigned to Sarah and Nick. Each pair was also responsible for developing the data flow diagram for a method of their respective classes. After finishing, we examined each other's tests to identify any inconsistencies or flaws in the testing methodology and to ensure compliance with JUnit testing code standards.

# 9 Any difficulties encountered, challenges overcome, and lessons learned from performing the lab

Text…

# 10 Comments/feedback on the lab itself

The lab provided a comprehensive understanding of whitebox testing with the use of JUnit and test coverage metrics. We liked how the tests we develop showed immediate results for coverage metrics and gave us great insight on what kind of tests should be developed for future projects.
